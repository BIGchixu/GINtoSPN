# Source code of GINtoSPN

#' @title Generate the header of a graphml file
#' @param graphml A list object with no content
#' @description Generate a header for a graphml file in mEPN schema. The input object should be an empty list.
#' @return A list with only one element containing the texts of a header for a graphml file in mEPN format.
#' @export
generate_header<-function(graphml){
  if(class(graphml) == "list"){
    print("Generate the graphml header following mEPN schema.")
    header<-'<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:java="http://www.yworks.com/xml/yfiles-common/1.0/java" xmlns:sys="http://www.yworks.com/xml/yfiles-common/markup/primitives/2.0" xmlns:x="http://www.yworks.com/xml/yfiles-common/markup/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:y="http://www.yworks.com/xml/graphml" xmlns:yed="http://www.yworks.com/xml/yed/3" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd">
  <!--Created by yEd 3.23.2-->
  <key attr.name="Description" attr.type="string" for="graph" id="d0"/>
  <key for="port" id="d1" yfiles.type="portgraphics"/>
  <key for="port" id="d2" yfiles.type="portgeometry"/>
  <key for="port" id="d3" yfiles.type="portuserdata"/>
  <key attr.name="url" attr.type="string" for="node" id="d4"/>
  <key attr.name="description" attr.type="string" for="node" id="d5"/>
  <key for="node" id="d6" yfiles.type="nodegraphics"/>
  <key for="graphml" id="d7" yfiles.type="resources"/>
  <key attr.name="url" attr.type="string" for="edge" id="d8"/>
  <key attr.name="description" attr.type="string" for="edge" id="d9"/>
  <key for="edge" id="d10" yfiles.type="edgegraphics"/>
  <graph edgedefault="directed" id="G">
    <data key="d0" xml:space="preserve"/>'
    graphml[[1]]<-header
    names(graphml)[1]<-"header"
  }else{
    print("Input should be a list for function generate_header.")
  }
  return(graphml)
}

#' @title Generate the ending of a graphml file
#' @param graphml A list object containing a header and other elements.
#' @param replace Logical. Whether to replace the last element in the list. Default is FALSE.
#' @description Generate the ending of a graphml file in mEPN schema.
#' @return A list containing a header, other elements and an end of a graphml file in mEPN format.
#' @export
generate_ending<-function(graphml,replace = FALSE){
  ending<-'  </graph>
  <data key="d7">
    <y:Resources/>
  </data>
</graphml>'
  if(class(graphml) == "list"){
    print("Generate the graphml ending following mEPN schema.")
    n<-length(graphml)
    if(replace){
      if(n > 0){
        graphml[[n]]<-ending
        names(graphml)[n]<-"Ending"
      }else{
        print("Empty list not allowed to generate an ending.")
      }
    }else{
      n=n+1
      graphml[[n]]<-ending
      names(graphml)[n]<-"Ending"
    }
  }else{
    print("Input should be a list for function generate_ending.")
  }
  return(graphml)
}

#' @title Generate the text of a node.
#' @param id The id of a node. The format of this id is "n" plus a number, for example "n1", "n2"...
#' @param height.geo Character. The "height" parameter in "Geometry" section. Default is "20.0".
#' @param width.geo Character. The "width" parameter in "Geometry" section. Default is "20.0".
#' @param x.geo Character. The "x" parameter in "Geometry" section. Default is randomly generated by runif(n=1,min=200, max =800).
#' @param y.geo Character. The "y" parameter in "Geometry" section. Default is randomly generated by runif(n=1,min=200, max =800).
#' @param color.fill Character. The "color" parameter in "Fill" section. Default is "#00CC33".
#' @param transparent Character. The "transparent" parameter in "Fill" section. Default is "false".
#' @param color.border Character. The "color" parameter in "BorderStyle" section. Default is "#000000".
#' @param type.border Character. The "type" parameter in "BorderStyle" section. Default is "line".
#' @param width.border Character. The "width" parameter in "BorderStyle" section. Default is "1.0".
#' @param alignment.nl Character. The "alignment" parameter in "NodeLabel" section. Default is "center".
#' @param autoSizePolicy.nl Character. The "autoSizePolicy" parameter in "NodeLabel" section. Default is "node_width".
#' @param fontFamily.nl Character. The "fontFamily" parameter in "NodeLabel" section. Default is "Arial Black".
#' @param fontSize.nl Character. The "fontSize" parameter in "NodeLabel" section. Default is "13".
#' @param fontStyle.nl Character. The height parameter in "NodeLabel" section. Default is "plain".
#' @param hasBackgroundColor.nl Character. The "hasBackgroundColor" parameter in "NodeLabel" section. Default is "false".
#' @param hasLineColor.nl Character. The "hasLineColor" parameter in "NodeLabel" section. Default is "false".
#' @param height.nl Character. The "height" parameter in "NodeLabel" section. Default is "22.33203125".
#' @param horizontalTextPosition.nl Character. The "horizontalTextPosition" parameter in "NodeLabel" section. Default is "center".
#' @param iconTextGap.nl Character. The "iconTextGap" parameter in "NodeLabel" section. Default is "4".
#' @param modelName.nl Character. The "modelName" parameter in "NodeLabel" section. Default is "internal".
#' @param modelPosition.nl Character. The "modelPosition" parameter in "NodeLabel" section. Default is "c".
#' @param textColor.nl Character. The "textColor" parameter in "NodeLabel" section. Default is "#000000".
#' @param verticalTextPosition.nl Character. The "verticalTextPosition" parameter in "NodeLabel" section. Default is "bottom".
#' @param visible.nl Character. The "visible" parameter in "NodeLabel" section. Default is "true".
#' @param width.nl Character. The "width" parameter in "NodeLabel" section. Default is "20.0".
#' @param x.nl Character. The "x" parameter in "NodeLabel" section. Default is "0".
#' @param xmlspace.nl Character. The "xmlspace" parameter in "NodeLabel" section. Default is "preserve".
#' @param y.nl Character. The "y" parameter in "NodeLabel" section. Default is "-1.166015625".
#' @param test.show Character. The text to show on the node when imported into an editor.
#' @param shape Character. The "type" parameter in "Shape" section. Default is "ellipse".
#' @description The basic function to generate the texts for a node. The default texts are based upon the schema of a transition node.
#' @return A character string of the texts for a node.
#' @export
basic_node<-function(id,height.geo = "20.0", width.geo = "20.0",x.geo=runif(n=1,min=200, max =800),y.geo=runif(n=1,min=200,max=800),
                     color.fill="#00CC33",transparent = "false",
                     color.border="#000000",type.border="line",width.border="1.0",
                     alignment.nl="center",autoSizePolicy.nl="node_width",fontFamily.nl="Arial Black",fontSize.nl="13",fontStyle.nl="plain",hasBackgroundColor.nl="false",hasLineColor.nl="false",height.nl="22.33203125",horizontalTextPosition.nl="center",
                                  iconTextGap.nl="4",modelName.nl="internal",modelPosition.nl="c",textColor.nl="#000000",verticalTextPosition.nl="bottom",visible.nl="true",width.nl="20.0",x.nl="0",xmlspace.nl="preserve",y.nl="-1.166015625",
                     text.show,shape="ellipse"){
  out.text<-paste0('<node id="',id,'">
      <data key="d6">
        <y:ShapeNode>
          <y:Geometry height="',height.geo,'" width="',width.geo,'" x="',x.geo,'" y="',y.geo,'"/>
          <y:Fill color="',color.fill,'" transparent="',transparent,'"/>
          <y:BorderStyle color="',color.border,'" type="',type.border,'" width="',width.border,'"/>
          <y:NodeLabel alignment="',alignment.nl,'" autoSizePolicy="',autoSizePolicy.nl,'" fontFamily="',fontFamily.nl,'" fontSize="',fontSize.nl,'" fontStyle="',fontStyle.nl,
          '" hasBackgroundColor="',hasBackgroundColor.nl,'" hasLineColor="',hasLineColor.nl,'" height="',height.nl,'" horizontalTextPosition="',horizontalTextPosition.nl,
          '" iconTextGap="',iconTextGap.nl,'" modelName="',modelName.nl,'" modelPosition="',modelPosition.nl,'" textColor="',textColor.nl,'" verticalTextPosition="',verticalTextPosition.nl,
          '" visible="',visible.nl,'" width="',width.nl,'" x="',x.nl,'" xml:space="',xmlspace.nl,'" y="',y.nl,'">',text.show,'</y:NodeLabel>
          <y:Shape type="',shape,'"/>
        </y:ShapeNode>
      </data>
    </node>')
  return(out.text)
}

#' @title Generate the texts of a transition node in "Degenerate" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Default is "/", which is the symbol of a Degenerate node in mEPN style.
#' @description Generate the texts of a transition node in "Degenerate" style of mEPN. Usually just provide the node id. Change of the text.show will change the type of the node.
#' @return A character string of a "Degenerate" node.
#' @export
new_degenerate<-function(id,text.show = "/"){
  tmp.text<-basic_node(id = id, x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#FFFFFF",
                       autoSizePolicy.nl = "content", fontSize.nl = "30",height.nl = "46.3046875",width.nl = "12.3349609375",x.nl = "3.83251953125", y.nl = "-13.15234375",
                       text.show = text.show)
  return(tmp.text)
}


#' @title Generate the texts of a transition node in "Catalysis" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Default is "C", which is the symbol of a Catalysis node in mEPN style.
#' @description Generate the texts of a transition node in "Catalysis" style of mEPN. Usually just provide the node id. Change of the text.show will change the type of the node.
#' @return A character string of a "Catalysis" node.
#' @export
new_catalysis<-function(id,text.show = "C"){
  tmp.text<-basic_node(id = id, x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#9999FF",
                       text.show = text.show)
  return(tmp.text)
}

#' @title Generate the texts of a transition node in "Binding" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Default is "B", which is the symbol of a Binding node in mEPN style.
#' @description Generate the texts of a transition node in "Binding" style of mEPN. Usually just provide the node id. Change of the text.show will change the type of the node.
#' @return A character string of a "Binding" node.
#' @export
new_binding<-function(id,text.show = "B"){
  tmp.text<-basic_node(id = id, x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#FFFF99",
                       text.show = text.show)
  return(tmp.text)
}

#' @title Generate the texts of a transition node in "Transcription" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Default is "TR", which is the symbol of a Transcription node in mEPN style.
#' @description Generate the texts of a transition node in "Transcription" style of mEPN. Usually just provide the node id. Change of the text.show will change the type of the node.
#' @return A character string of a "Transcription" node.
#' @export
new_transcription<-function(id,text.show = "TR"){
  tmp.text<-basic_node(id = id, x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#99CCFF",width.nl = "23.5", x.nl = "-1.75",
                       text.show = text.show)
  return(tmp.text)
}

#' @title Generate the texts of a transition node in "Translation" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Default is "TL", which is the symbol of a Translation node in mEPN style.
#' @description Generate the texts of a transition node in "Translation" style of mEPN. Usually just provide the node id. Change of the text.show will change the type of the node.
#' @return A character string of a "Translation" node.
#' @export
new_translation<-function(id,text.show = "TL"){
  tmp.text<-basic_node(id = id, x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#99CCFF",width.nl = "22.05908203125", x.nl = "-1.029541015625",
                       text.show = text.show)
  return(tmp.text)
}

#' @title Generate the texts of a place node in "Protein" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Can be the gene symbol. 
#' @description Generate the texts of a place node in "Protein" style of mEPN. The text.show parameter does not affect the format, and can be filled with the gene symbol or id etc..
#' @return A character string of a "Protein" node.
#' @export
new_simple_protein<-function(id,text.show){
  tmp.text<-basic_node(id = id,width.geo = "80.0", x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#CCFFFF",fontFamily.nl="Arial",height.nl="18.5234375",width.nl="35.07177734375",
                       x.nl = "22.464111328125", y.nl = "0.73828125", text.show = text.show,shape = "roundrectangle")
  return(tmp.text)
}

#' @title Generate the texts of a place node in "Small Biochemical" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Can be the name of the chemical. 
#' @description Generate the texts of a place node in "Small Biochemical" style of mEPN. The text.show parameter does not affect the format, and can be filled with the chemical's id.
#' @return A character string of a "Small Chemical" node.
#' @export
new_smallBiochemical<-function(id,text.show){
  tmp.text<-basic_node(id = id, height.geo = "25.0", width.geo = "80.0", x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#FFCC99", autoSizePolicy.nl = "content", fontFamily.nl = "Arial",
                       height.nl="18.5234375",width.nl="104.419921875", x.nl = "-12.2099609375", y.nl = "3.23828125", text.show = text.show, shape = "hexagon")
  return(tmp.text)
}

#' @title Generate the texts of a place node in "Complex" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Can be the name of the complex. 
#' @description Generate the texts of a place node in "Complex" style of mEPN. The text.show parameter does not affect the format, and can be filled with the name of the complex.
#' @return A character string of a "Complex" node.
#' @export
new_complex<-function(id,text.show){
  text.show<-gsub(":","-",text.show)
  text.show<-gsub("_",":",text.show)
  tmp.text<-basic_node(id = id, height.geo = "40.0", width.geo = "100.0", x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#FFFF99", autoSizePolicy.nl = "content",
                       height.nl="22.33203125",width.nl="8.3291015625", x.nl = "45.83544921875", y.nl = "8.833984375", text.show = text.show, shape = "roundrectangle")
  return(tmp.text)
}

#' @title Generate the texts of a place node in "Input" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @description Generate the texts of a place node in "Input" style of mEPN. The input node will be a flat rectangle.
#' @return A character string of a "Input" node.
#' @export
new_input_h<-function(id){
  tmp.text<-paste0('<node id="',id,'">
      <data key="d6">
        <y:ShapeNode>
          <y:Geometry height="6.0" width="30.0" x="',runif(n=1,min=200, max =800),'" y="',runif(n=1,min=200, max =800),'"/>
          <y:Fill color="#000000" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" borderDistance="0.0" fontFamily="Dialog" fontSize="13" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" hasText="false" height="4.0" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="c" textColor="#000000" verticalTextPosition="bottom" visible="true" width="4.0" x="13.0" y="1.0"/>
          <y:Shape type="rectangle"/>
        </y:ShapeNode>
      </data>
    </node>')
  return(tmp.text)
}

#' @title Generate the texts of a place node in "Input" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @description Generate the texts of a place node in "Input" style of mEPN. The input node will be a tall and slim rectangle.
#' @return A character string of a "Input" node.
#' @export
new_input_v<-function(id){
  tmp.text<-paste0('<node id="',id,'">
      <data key="d6">
        <y:ShapeNode>
          <y:Geometry height="30.0" width="6.0" x="',runif(n=1,min=200, max =800),'" y="',runif(n=1,min=200, max =800),'"/>
          <y:Fill color="#000000" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" borderDistance="0.0" fontFamily="Dialog" fontSize="13" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" hasText="false" height="4.0" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="c" textColor="#000000" verticalTextPosition="bottom" visible="true" width="4.0" x="1.0" y="13.0"/>
          <y:Shape type="rectangle"/>
        </y:ShapeNode>
      </data>
    </node>')
  return(tmp.text)
}

#' @title Generate the texts of a place node in "DNA region" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Can be the annotation of the DNA region. 
#' @description Generate the texts of a place node in "Complex" style of mEPN. The text.show parameter does not affect the format, and can be filled with the annotation of the DNA region.
#' @return A character string of a "DNA region" node.
#' @export
new_dnaRegion<-function(id,text.show){
  tmp.text<-basic_node(id = id,width.geo = "80.0", x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#BAE0BA",fontFamily.nl="Arial",height.nl="18.5234375",width.nl="80.0",x.nl = "0", y.nl="0.73828125",
                       text.show = text.show,shape = "parallelogram")
  return(tmp.text)
}

#' @title Generate the texts of a place node in "RNA" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param text.show The text.show parameter which will be passed to function "basic_node". Can be the name of the RNA transcript. 
#' @description Generate the texts of a place node in "RNA" style of mEPN. The text.show parameter does not affect the format, and can be filled with the name of the RNA transcript.
#' @return A character string of a "RNA" node.
#' @export
new_mRNA<-function(id,text.show){
  tmp.text<-basic_node(id = id,width.geo = "80.0", x.geo = runif(n=1,min=200, max =800), y.geo = runif(n=1,min=200, max =800), color.fill = "#C0C0C0",fontFamily.nl="Arial",height.nl="18.5234375",width.nl="80.0",x.nl = "0", y.nl="0.73828125",
                       text.show = text.show,shape = "parallelogram")
  return(tmp.text)
}

#' @title Generate the texts of a transition node in "Delayed transition" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @description Generate the texts of a transition node in "Delayed transition" style of mEPN. This type of transitions are usually coupled with the "Delayed place" nodes to mimic the delayed signals of stimulus.
#' @return A character string of a "Delayed transition" node.
#' @export
new_delayTransit<-function(id){
  tmp.text<-paste0('<node id="',id,'">
      <data key="d4" xml:space="preserve"/>
      <data key="d6">
        <y:ShapeNode>
          <y:Geometry height="10.0" width="10.0" x="',runif(n=1,min=200, max =800),'" y="',runif(n=1,min=200, max =800),'"/>
          <y:Fill color="#000000" color2="#000000" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" hasText="false" height="4.0" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="c" textColor="#000000" verticalTextPosition="bottom" visible="true" width="4.0" x="3.0" y="3.0"/>
          <y:Shape type="diamond"/>
        </y:ShapeNode>
      </data>
    </node>')
  return(tmp.text)
}

#' @title Generate the texts of a place node in "Delayed place" style of mEPN
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @description Generate the texts of a place node in "Delayed place" style of mEPN. This type of places are usually coupled with the "Delayed transition" nodes to mimic the delayed signals of stimulus.
#' @return A character string of a "Delayed place" node.
#' @export
new_delayPlace<-function(id){
  tmp.text<-paste0('<node id="',id,'">
      <data key="d4" xml:space="preserve"/>
      <data key="d6">
        <y:ShapeNode>
          <y:Geometry height="10.0" width="10.0" x="',runif(n=1,min=200, max =800),'" y="',runif(n=1,min=200, max =800),'"/>
          <y:Fill color="#FFFFFF" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="13" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" hasText="false" height="4.0" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="c" textColor="#000000" verticalTextPosition="bottom" visible="true" width="4.0" x="3.0" y="3.0"/>
          <y:Shape type="ellipse"/>
        </y:ShapeNode>
      </data>
    </node>')
  return(tmp.text)
}

#' @title Generate the texts of a simple edge with no weights in mEPN style
#' @param id The id of the edge. Should be in the format of "e" plus a number, for example "e1", "e2"...
#' @param source The source node's id of this edge.
#' @param target The target node's id of this edge.
#' @param type The type of this edge. Should be either "standard" (positive) or "t_shape" (negative). 
#' @description Generate the texts of a simple edge in mEPN style.
#' @return A character string of a simple edge.
#' @export
new_simple_edge<-function(id,source,target,type=c("standard","t_shape")){
  tmp.text<-paste0('<edge id="',id,'" source="',source,'" target="',target,'">
      <data key="d9"/>
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="0.0" sy="0.0" tx="0.0" ty="0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="',type,'"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>')
  return(tmp.text)
}

#' @title Generate the texts of a weighted edge in mEPN style
#' @param id The id of the edge. Should be in the format of "e" plus a number, for example "e1", "e2"...
#' @param source The source node's id of this edge.
#' @param target The target node's id of this edge.
#' @param weight The weight of this edge. 
#' @description Generate the texts of a weighted edge in mEPN style. Currently this type of edge is only used for input tokens.
#' @return A character string of a weighted edge.
#' @export
new_input_edge<-function(id,source,target,weight){
  tmp.text<-paste0('<edge id="',id,'" source="',source,'" target="',target,'">
      <data key="d9"/>
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="0.0" sy="0.0" tx="0.0" ty="0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:EdgeLabel alignment="center" configuration="AutoFlippingLabel" distance="2.0" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="18.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="custom" preferredPlacement="anywhere" ratio="0.5" textColor="#000000" verticalTextPosition="bottom" visible="true" width="26.763671875" x="26.54606612852581" xml:space="preserve" y="22.261273231595055">',
                   weight,'<y:LabelModel><y:SmartEdgeLabelModel autoRotationEnabled="false" defaultAngle="0.0" defaultDistance="10.0"/></y:LabelModel><y:ModelParameter><y:SmartEdgeLabelModelParameter angle="0.0" distance="30.0" distanceToCenter="true" position="right" ratio="0.5" segment="0"/></y:ModelParameter><y:PreferredPlacementDescriptor angle="0.0" angleOffsetOnRightSide="0" angleReference="absolute" angleRotationOnRightSide="co" distance="-1.0" frozen="true" placement="anywhere" side="anywhere" sideReference="relative_to_edge_flow"/></y:EdgeLabel>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>')
  return(tmp.text)
}


#' @title Check whether the node id exists in a graphml list
#' @param id The id of the node. Should be in the format of "n" plus a number, for example "n1", "n2"...
#' @param graphml The graphml list.
#' @description Check whether a given node id already exists in a graphml list
#' @return Logical value, TRUE or FALSE
#' @export
checkNodeExist<-function(id,graphml){ #return true: exist or false: not exist
  elements<-names(graphml)
  if(id %in% elements){
    result <- TRUE
  }else{
    result <- FALSE
  }
  return(result)
}

#' @title Generate a number for a new node
#' @param id.node.num Any number.
#' @param graphml A graphml list.
#' @description Generate a number for a new node. The input id.node.num is not strictly required now. Can be given with any number.
#' @return A numerical number, which is the number of existing node plus 1.
#' @export
new_node_id_num<-function(id.node.num,graphml){
  id.node.num<-length(grep("n",names(graphml)))+1
  return(id.node.num)
}

#' @title Generate a number for a new edge
#' @param id.edge.num Any number.
#' @param graphml A graphml list.
#' @description Generate a number for a new edge. The input id.edge.num is not strictly required now. Can be given with any number.
#' @return A numerical number, which is the number of existing edge plus 1.
#' @export
new_edge_id_num<-function(id.edge.num,graphml){
  id.edge.num<-length(grep("e",names(graphml)))-1+1 # the 'header' will add 1 to the length
  return(id.edge.num)
}

#' @title Distinguish the type of a given node
#' @param node.text The text.show of a node. Basically the symbols which will be shown in a GraphML editor for this node. 
#' @param cdglist.this A list of coding genes' gene symbol.
#' @description Distinguish the type of a given node by its "text.show". This "text.show" was the same as the one used when creating this node.
#' @return A character string of the node type. Can be one of "Catalysis", "Complex", "RNA", "Promoter", "Transcription", "Translation", "Binding", "Protein", and "Chemical".
#' @export
decide_node_type<-function(node.text,cdglist.this){ #return one of the following: c("Catalysis","Complex","RNA","Promoter","Protein","Chemical")
  if(grepl(";",node.text)){ # the intermediate node
    type <- "Catalysis" # Catalysis, Binding, activation ... are all unified as 'positive' in Meta-pathway
  }else if(grepl("_", node.text)){
    type <- "Complex"
  }else if(grepl(".RNA",node.text)){
    type <- "RNA"
  }else if(grepl(".state",node.text)){
    type <- "Promoter"
  }else if(node.text == "TR"){
    type <- "Transcription"
  }else if(node.text == "TL"){
    type <- "Translation"
  }else if(node.text == "B"){
    type <- "Binding"
  }else if(node.text %in% cdglist.this){
    type <- "Protein"
  }else{
    type <- "Chemical"
  }
  return(type)
}

#' @title Generate the text of a new node.
#' @param id A node id which has not been used.
#' @param text.show The text which is required for a node. If the node is a place node, then usually text.show is the name of the entity, for example protein name, gene name etc.. If the node is a transition node, then text.show will reflect the type of the transition.
#' @description Generate the text of a new node based upon its type.
#' @return A character string which is the text of a node.
#' @export
new_node_text<-function(id,text.show,type){
  if(type == "Protein"){
    tmp.text<-new_simple_protein(id,text.show)
  }else if(type == "RNA"){
    tmp.text<-new_mRNA(id,text.show)
  }else if(type == "Promoter"){
    tmp.text<-new_dnaRegion(id,text.show)
  }else if(type == "Chemical"){
    tmp.text<-new_smallBiochemical(id,text.show)
  }else if(type == "Complex"){
    tmp.text<-new_complex(id,text.show)
  }else if(type == "Catalysis"){
    tmp.text<-new_catalysis(id)
  }else if(type == "Binding"){
    tmp.text<-new_binding(id,text.show)
  }else if(type == "Transcription"){
    tmp.text<-new_transcription(id,text.show)
  }else if(type == "Translation"){
    tmp.text<-new_translation(id,text.show)
  }else if(type == "Input"){
    tmp.text<-new_input_v(id) #input node does not need a text to show
  }else if(type == "Degenerate"){
    tmp.text<-new_degenerate(id) # the text shown on a degenerate node is '/'
  }else{
    print(paste0("Unexpected node type specified: ",type,". Empty node text generated."))
    tmp.text<-""
  }
  return(tmp.text)
}

#' @title Generate the text of a new edge.
#' @param id An edge id which has not been used.
#' @param source The source node id.
#' @param target The target node id.
#' @param type The type of the edge. Should be one of "positive", "negative" and "input".
#' @param weight Numerical. The weight of an Input edge. Can be ignored when creating a simple edge.
#' @description Generate the text of a new edge based upon its source node id, target node id, type and weight (if it's an Input edge).
#' @return A character string of an edge.
#' @export
new_edge_text<-function(id,source,target,type,weight = ""){
  if(type == "positive"){
    tmp.text<-new_simple_edge(id,source,target,type="standard")
  }else if(type == "negative"){
    tmp.text<-new_simple_edge(id,source,target,type = "t_shape")
  }else if(type == "input"){
    tmp.text<-new_input_edge(id,source,target,weight)
  }else{
    print(paste0("Unexpected edge type specified: ",type,". Empty edge text generated."))
    tmp.text<-""
  }
  return(tmp.text)
}

#' @title Convert an edge into a list
#' @param id.edge.num The number of an edge id. An edge id consists of "e" and a number, for example "e1", "e2"...
#' @param source The source node id.
#' @param target The target node id.
#' @param edgeType The type of the edge. Should be either "positive" or "negative".
#' @param graphml The GraphML list.
#' @description Generate a list of edge text and the meta info. Meta info is useful for accelerating downstream conversion.
#' @return A list of two elements. The first one is the text of an edge, named "edge_texts". The second is "metainfo", which is a dataframe with three columns, id, textShow (stores the source and target), and type.
#' @export
convert_edge_to_graphml<-function(id.edge.num,source,target,edgeType = c("positive","negative"),graphml){ # two nodes and one edge, no weighted edge
  result.list<-list()
  
  id.edge.num = new_edge_id_num(id.edge.num,graphml)
  e<-paste0("e",id.edge.num)

  metainfo<-data.frame(id=c(e), 
                       textShow=paste0(source,"_",target,"_"), 
                       type=c(edgeType))
  
  result.list[[1]]<-new_edge_text(e,source,target,edgeType)
  result.list[[2]]<-metainfo
  names(result.list)<-c("edge_texts","metainfo")
  return(result.list)
}

#' @title Convert an edge list into a list
#' @param el An edge list with three columns, the text.show of the source node, the text.show of the target node, and the edge types.
#' @param graphml The GraphML list.
#' @param metainfo.node A dataframe containing the meta info of nodes. This dataframe consists of three columns, id, textShow, and type
#' @param cdglist A list of the coding genes' gene symbols.
#' @description Generate a list of edge texts and the meta info according to an input edgelist. The edgelist's format is compatible with global integrative network's (GIN's) edgelist. When detected GRN network, it will automatically create new nodes and edges to fit the Petri Net design.
#' @return A list of two elements. The first one is the list of nodes and edges, named "graphml". The second is "metainfo", which is a dataframe with three columns, id, textShow (stores the source and target), and type.
#' @export
convert_edgelist_to_graphml<-function(el, graphml, metainfo.node, cdglist){
  metainfo<-data.frame(id="",textShow="",type="") # this will create an empty line
  result<-list()
  if(dim(el)[1] > 0){
    #(n=length(graphml))
    for(i in 1:dim(el)[1]){
      n.source<-metainfo.node$id[metainfo.node$textShow == el[i,1]]
      n.target<-metainfo.node$id[metainfo.node$textShow == el[i,2]]
      # If the source and target nodes are one of the types of "promoter" or "RNA", extra nodes of "binding", "transcription" and "translation" need to be introduced
      type.source<-decide_node_type(el[i,1],cdglist)
      type.target<-decide_node_type(el[i,2],cdglist)
      # The structure of GRN is fixed in GIN: TF -> promoter -> RNA -> protein
      if(type.source == "Promoter"){ # promoter -> RNA, transcription
        # Create a new transition node
        tmp.new<-convert_node_to_graphml(1,"TR",graphml,cdglist)
        
        # Since a new node has been introduced, we update the temporary graphml and the metainfo.node
        n=length(graphml)
        n = n+1
        graphml[[n]]<-tmp.new$node_texts
        names(graphml)[n]<-tmp.new$metainfo$id
        metainfo.node<-rbind(metainfo.node, tmp.new$metainfo)
        metainfo<-rbind(metainfo,tmp.new$metainfo)
        
        # Two edges need to be created: promoter -> TR, and TR -> RNA
        ## promoter -> TR
        tmp.line<-convert_edge_to_graphml(i,n.source,tmp.new$metainfo$id,"positive",graphml)
        n = n+1
        graphml[[n]]<-tmp.line$edge_texts
        names(graphml)[n]<-tmp.line$metainfo$id
        metainfo<-rbind(metainfo,tmp.line$metainfo)
        ## TR -> RNA
        tmp.line<-convert_edge_to_graphml(i,tmp.new$metainfo$id,n.target,"positive",graphml)
        n = n+1
        graphml[[n]]<-tmp.line$edge_texts
        names(graphml)[n]<-tmp.line$metainfo$id
        metainfo<-rbind(metainfo,tmp.line$metainfo)
      }else if(type.source == "RNA"){ # RNA -> protein
        # Create a new transition node
        tmp.new<-convert_node_to_graphml(1,"TL",graphml,cdglist)
        
        # Since a new node has been introduced, we update the temporary graphml and the metainfo.node
        n=length(graphml)
        n = n+1
        graphml[[n]]<-tmp.new$node_texts
        names(graphml)[n]<-tmp.new$metainfo$id
        metainfo.node<-rbind(metainfo.node, tmp.new$metainfo)
        metainfo<-rbind(metainfo,tmp.new$metainfo)
        
        # Two edges need to be created: RNA -> TL, and TL -> protein
        ## RNA -> TL
        tmp.line<-convert_edge_to_graphml(i,n.source,tmp.new$metainfo$id,"positive",graphml)
        n = n+1
        graphml[[n]]<-tmp.line$edge_texts
        names(graphml)[n]<-tmp.line$metainfo$id
        metainfo<-rbind(metainfo,tmp.line$metainfo)
        ## TL -> protein
        tmp.line<-convert_edge_to_graphml(i,tmp.new$metainfo$id,n.target,"positive",graphml)
        n = n+1
        graphml[[n]]<-tmp.line$edge_texts
        names(graphml)[n]<-tmp.line$metainfo$id
        metainfo<-rbind(metainfo,tmp.line$metainfo)
      }else if(type.target == "Promoter"){ # TF -> promoter
        # Create a new transition node
        tmp.new<-convert_node_to_graphml(1,"B",graphml,cdglist)
        
        # Since a new node has been introduced, we update the temporary graphml and the metainfo.node
        n=length(graphml)
        n = n+1
        graphml[[n]]<-tmp.new$node_texts
        names(graphml)[n]<-tmp.new$metainfo$id
        metainfo.node<-rbind(metainfo.node, tmp.new$metainfo)
        metainfo<-rbind(metainfo,tmp.new$metainfo)
        
        # Two edges need to be created: RNA -> TL, and TL -> protein
        ## TF -> B
        tmp.line<-convert_edge_to_graphml(i,n.source,tmp.new$metainfo$id,"positive",graphml)
        n = n+1
        graphml[[n]]<-tmp.line$edge_texts
        names(graphml)[n]<-tmp.line$metainfo$id
        metainfo<-rbind(metainfo,tmp.line$metainfo)
        ## B -> promoter
        tmp.line<-convert_edge_to_graphml(i,tmp.new$metainfo$id,n.target,el[i,3],graphml)
        n = n+1
        graphml[[n]]<-tmp.line$edge_texts
        names(graphml)[n]<-tmp.line$metainfo$id
        metainfo<-rbind(metainfo,tmp.line$metainfo)
      }else{
        n=length(graphml)
        tmp.line<-convert_edge_to_graphml(i,n.source,n.target,el[i,3],graphml)
        (n = n+1)
        graphml[[n]]<-tmp.line$edge_texts
        names(graphml)[n]<-tmp.line$metainfo$id
        metainfo<-rbind(metainfo,tmp.line$metainfo)
      }
    }
    metainfo<-metainfo[-1,] #remove the first empty line
  }else{
    print("Empty input edge list. No new edges generated.")
    
  }
  result[[1]]<-graphml
  result[[2]]<-metainfo
  names(result)<-c("graphml","metainfo")
  return(result)
}

#' @title Convert a node into a list
#' @param id.node.num The number of a node id. A node id consists of "n" and a number, for example "n1", "n2"...
#' @param text.show The text.show used when creating a new node. If the node is a place node, then it will be the protein's name, RNA's name etc.. If the node is a transition node, it will be the symbol of the transition.
#' @param graphml The GraphML list.
#' @param cdglist The list of coding genes' gene symbols.
#' @description Generate a list of node text and the meta info. Meta info is useful for accelerating downstream conversion.
#' @return A list of two elements. The first one is the text of a node, named "node_texts". The second is "metainfo", which is a dataframe with three columns, id, textShow, and type.
#' @export
convert_node_to_graphml<-function(id.node.num,text.show,graphml,cdglist){
  result.list<-list()
  id.node.num<-new_node_id_num(id.node.num,graphml) # Check whether the node id num has been used. If used, find a new one
  n<-paste0("n",id.node.num)
  
  type.n<-decide_node_type(text.show,cdglist)
   
  metainfo<-data.frame(id=c(n), 
                       textShow=c(text.show), 
                       type=c(type.n))
  
  result.list[[1]]<-new_node_text(n,text.show,type.n)
  result.list[[2]]<-metainfo
  names(result.list)<-c("node_texts","metainfo")
  return(result.list)
}

#' @title Convert a vector of nodes into a list
#' @param nodeVec The vector of node names. NOT node ids.
#' @param graphml The GraphML list.
#' @param cdglist The list of coding genes' gene symbols.
#' @description Generate a list of node texts and the meta info. Meta info is useful for accelerating downstream conversion.
#' @return A list of two elements. The first one is the list of nodes and edges, named "graphml". The second is "metainfo", which is a dataframe with three columns, id, textShow, and type.
#' @export
convert_nodeVec_to_graphml<-function(nodeVec,graphml,cdglist){ #nodeVec should be a vector of nodes' names
  metainfo<-data.frame(id="",textShow="",type="") # this will create an empty line
  result<-list()
  if(length(nodeVec) > 0){
    (n=length(graphml))
    for(i in 1:length(nodeVec)){
      tmp.line<-convert_node_to_graphml(i,nodeVec[i],graphml,cdglist)
      (j = n+i)
      graphml[[j]]<-tmp.line$node_texts
      names(graphml)[j]<-tmp.line$metainfo$id
      metainfo<-rbind(metainfo,tmp.line$metainfo)
    }
    metainfo<-metainfo[-1,] #remove the first empty line
  }else{
    print("Empty input edge list. No new edges generated.")
  }
  result[[1]]<-graphml
  result[[2]]<-metainfo
  names(result)<-c("graphml","metainfo")
  return(result)
}

#' @title Convert an igraph object into a list
#' @param g The igraph object to be converted.
#' @param cdglist The list of coding genes' gene symbols.
#' @param inputlist The list of input tokens. Should be of two columns, the first is the text.show of the node. The second is the amount of tokens. Currently only works for RNA expressions.
#' @description Convert an igraph object into a list. If provided with an input list, then the RNA nodes which intersect with the input list will be given one extra input node and one input edge. The expression will be used as the weight of the edge.
#' @return A list of two elements. The first one is the list of a header, nodes and edges, and an end, named "graphml". The second is "metainfo", which is a dataframe with three columns, id, textShow, and type.
#' @export
convert_graph_to_graphml<-function(g,cdglist,inputlist="none"){
  # Generate edge list
  if(length(E(g)$type) == 0){
    print("No edge type specified in the graph. Treat all the edges as 'positive'.")
    E(g)$type = "positive"
  }
  el<-as.data.frame(as_edgelist(g,names = TRUE))
  el$type<-E(g)$type
  colnames(el)<-c("source","target","type")
  
  # Generate node vector
  node.vec<-V(g)$name
  
  # Initialize the object, and generate the header of the file.
  out.graphml<-list()
  out.graphml<-generate_header(out.graphml)
  # Process the node vector
  tmp<-convert_nodeVec_to_graphml(node.vec, out.graphml, cdglist)
  out.graphml<-tmp$graphml
  metainfo<-tmp$metainfo # metainfo of the nodes
  # Process the edge list
  tmp<-convert_edgelist_to_graphml(el, out.graphml, metainfo,cdglist)
  out.graphml<-tmp$graphml
  metainfo<-rbind(metainfo,tmp$metainfo)
  if(class(inputlist) == "data.frame"){ #if an input list has been specified
    node.rna<-metainfo$textShow[metainfo$type == "Protein"]
    if(length(node.rna) > 0){
      node.expr<-inputlist[inputlist[,1] %in% node.rna,]
      if(dim(node.expr)[1] > 0){
        print(paste0("Valide input data found. Adding input nodes."))
        n.node.start<-length(grep("n",metainfo$id)) # number of existing nodes 
        n.edge.start<-length(grep("e",metainfo$id)) # number of existing edges 
        n.graphml<-length(out.graphml) # the number of items in the output list
        id.node=c()
        id.edge=c()
        textShow.node = c()
        textShow.edge = c()
        type.node=c()
        type.edge=c()
        for(i in 1:dim(node.expr)[1]){
          # If there's no .RNA node for this protein, add one
          if(length(metainfo$id[metainfo$textShow == paste0(node.expr[i,1],".RNA")]) == 0){
            # Initialize meta info vectors
            tmp.id.node=c()
            tmp.id.edge=c()
            tmp.textShow.node = c()
            tmp.textShow.edge = c()
            tmp.type.node=c()
            tmp.type.edge=c()
            # Add a new .RNA node
            # Note the ids of node, edge, and the index in the graphml list will pass to the next part
            # While the meta info will be updated within this part
            n.node.start = n.node.start + 1
            id.node.new<-paste0("n",n.node.start)
            id.rna<-id.node.new
            n.graphml = n.graphml + 1
            out.graphml[[n.graphml]]<-new_node_text(id.node.new, paste0(node.expr[i,1],".RNA"), "RNA")
            names(out.graphml)[n.graphml] <- id.node.new
            # Metainfo
            tmp.tmp.textShow<-paste0(node.expr[i,1],".RNA") 
            tmp.textShow.node<-c(tmp.textShow.node, tmp.tmp.textShow)
            tmp.id.node<-c(tmp.id.node,id.node.new)
            tmp.type.node<-c(tmp.type.node,"RNA")
            
            #Add a new translation node
            n.node.start = n.node.start + 1
            id.node.new<-paste0("n",n.node.start)
            id.tl<-id.node.new
            n.graphml = n.graphml + 1
            out.graphml[[n.graphml]]<-new_node_text(id.node.new, "TL", "Translation")
            names(out.graphml)[n.graphml] <- id.node.new
            # Metainfo
            tmp.textShow.node<-c(tmp.textShow.node, "TL")
            tmp.id.node<-c(tmp.id.node,id.node.new)
            tmp.type.node<-c(tmp.type.node,"Translation")
            
            #Add a new edge starting from .RNA node to the Translation node
            n.graphml = n.graphml + 1
            n.edge.start = n.edge.start + 1
            id.edge.new<-paste0("e",n.edge.start)
            # source node of the edge: id.rna
            # target node of the edge: id.tl
            out.graphml[[n.graphml]]<-new_simple_edge(id = id.edge.new,
                                                     source = id.rna,
                                                     target = id.tl,
                                                     type = "standard")
            names(out.graphml)[n.graphml] <- id.edge.new
            # Metainfo
            tmp.textShow.edge<-c(tmp.textShow.edge, paste0(id.rna,"_",id.tl,"_"))
            tmp.id.edge<-c(tmp.id.edge,id.edge.new)
            tmp.type.edge<-c(tmp.type.edge, "positive")
            
            #Add a new edge starting from the Translation node to the protein node
            n.graphml = n.graphml + 1
            n.edge.start = n.edge.start + 1
            id.edge.new<-paste0("e",n.edge.start)
            # source node of the edge: id.tl
            # target node of the edge: metainfo$id[metainfo$textShow == node.expr[i,1]]
            out.graphml[[n.graphml]]<-new_simple_edge(id = id.edge.new,
                                                      source = id.node.new,
                                                      target = metainfo$id[metainfo$textShow == node.expr[i,1]],
                                                      type = "standard")
            names(out.graphml)[n.graphml] <- id.edge.new
            # Metainfo
            tmp.textShow.edge<-c(tmp.textShow.edge, paste0(id.node.new,"_",metainfo$id[metainfo$textShow == node.expr[i,1]],"_"))
            tmp.id.edge<-c(tmp.id.edge,id.edge.new)
            tmp.type.edge<-c(tmp.type.edge, "positive")
            # After we added the .RNA node if necessary, we have to update the metainfo so that the following code will know that there is a .RNA node in the graph
            tmp.tmp.meta<-data.frame(id = c(tmp.id.node, tmp.id.edge), textShow = c(tmp.textShow.node, tmp.textShow.edge), type = c(tmp.type.node,tmp.type.edge))
            metainfo<-rbind(metainfo,tmp.tmp.meta)
          }
          
          # Add a new input node
          n.node.start = n.node.start + 1
          id.node.new<-paste0("n",n.node.start)
          n.graphml = n.graphml + 1
          out.graphml[[n.graphml]]<-new_node_text(id.node.new,"tmp","Input") # the second argument is ignored for an input node
          names(out.graphml)[n.graphml] <- id.node.new
          
          # Metainfo
          tmp.textShow<-paste0(node.expr[i,1],"-Input") # Names of the proteins
          textShow.node<-c(textShow.node, tmp.textShow)
          id.node<-c(id.node,id.node.new)
          type.node<-c(type.node,"Input")
          
          #Add a new edge with weight
          n.graphml = n.graphml + 1
          n.edge.start = n.edge.start + 1
          id.edge.new<-paste0("e",n.edge.start)
          # source node of the edge: id.node.new
          # target node of the edge: metainfo$id[metainfo$textShow == paste0(node.expr[i,1],".RNA")]
          # weight of the edge: node.expr[i,2]
          out.graphml[[n.graphml]]<-new_input_edge(id = id.edge.new,
                                                   source = id.node.new,
                                                   target = metainfo$id[metainfo$textShow == paste0(node.expr[i,1],".RNA")],
                                                   weight = node.expr[i,2])
          names(out.graphml)[n.graphml] <- id.edge.new
          # Metainfo
          textShow.edge<-c(textShow.edge, paste0(id.node.new,"_",metainfo$id[metainfo$textShow == paste0(node.expr[i,1],".RNA")],"_")) # Actually in the mEPN format, the text showing on the edge is the weight
          id.edge<-c(id.edge,id.edge.new)
          type.edge<-c(type.edge, "positive")
          
          # Add a new degenerate node
          n.node.start = n.node.start + 1
          id.node.new<-paste0("n",n.node.start)
          n.graphml = n.graphml + 1
          out.graphml[[n.graphml]]<-new_node_text(id.node.new,"tmp","Degenerate") # the second argument is ignored for an input node
          names(out.graphml)[n.graphml] <- id.node.new
          textShow.node<-c(textShow.node, '/')
          id.node<-c(id.node,id.node.new)
          type.node<-c(type.node, "Degenerate")
          
          # Add a new edge targeting the degenerate node from the RNA node
          n.graphml = n.graphml + 1
          n.edge.start = n.edge.start + 1
          id.edge.new<-paste0("e",n.edge.start)
          # source node of the edge: metainfo$id[metainfo$textShow == paste0(node.expr[i,1],".RNA")]
          # target node of the edge: id.node.new
          out.graphml[[n.graphml]]<-new_simple_edge(id = id.edge.new,
                                                   source = metainfo$id[metainfo$textShow == paste0(node.expr[i,1],".RNA")],
                                                   target = id.node.new,
                                                   type = "standard")
          names(out.graphml)[n.graphml] <- id.edge.new
          textShow.edge<-c(textShow.edge, paste0(metainfo$id[metainfo$textShow == paste0(node.expr[i,1],".RNA")],"_",id.node.new,"_"))
          id.edge<-c(id.edge,id.edge.new)
          type.edge<-c(type.edge,"positive")
        }
        tmp.meta<-data.frame(id = c(id.node, id.edge), textShow = c(textShow.node, textShow.edge), type = c(type.node,type.edge))
        metainfo<-rbind(metainfo,tmp.meta)
        
        # Add input node and edge for chemicals
        nodes.chem<-metainfo$textShow[metainfo$type == "Chemical"]
        n.node.start<-length(grep("n",metainfo$id)) # number of existing nodes 
        n.edge.start<-length(grep("e",metainfo$id)) # number of existing edges 
        n.graphml<-length(out.graphml) # the number of items in the output list
        id.node=c()
        id.edge=c()
        textShow.node = c()
        textShow.edge = c()
        for(i in 1:length(nodes.chem)){
          # Add a new input node
          n.node.start = n.node.start + 1
          id.node.new<-paste0("n",n.node.start)
          n.graphml = n.graphml + 1
          out.graphml[[n.graphml]]<-new_node_text(id.node.new,"tmp","Input") # the second argument is ignored for an input node
          names(out.graphml)[n.graphml] <- id.node.new
          
          # Metainfo
          tmp.textShow<-paste0(nodes.chem[i],"-Input") # Names of the proteins
          textShow.node<-c(textShow.node, tmp.textShow)
          id.node<-c(id.node,id.node.new)
          
          #Add a new edge with weight
          n.graphml = n.graphml + 1
          n.edge.start = n.edge.start + 1
          id.edge.new<-paste0("e",n.edge.start)
          # source node of the edge: id.node.new
          # target node of the edge: metainfo$id[metainfo$textShow == nodes.chem[i]]
          # weight of the edge: 10
          out.graphml[[n.graphml]]<-new_input_edge(id = id.edge.new,
                                                   source = id.node.new,
                                                   target = metainfo$id[metainfo$textShow == nodes.chem[i]],
                                                   weight = "1000")
          names(out.graphml)[n.graphml] <- id.edge.new
          # Metainfo
          textShow.edge<-c(textShow.edge, paste0(id.node.new,"_",metainfo$id[metainfo$textShow == nodes.chem[i]],"_")) # Actually in the mEPN format, the text showing on the edge is the weight
          id.edge<-c(id.edge,id.edge.new)
        }
        
        tmp.meta<-data.frame(id = c(id.node, id.edge), textShow = c(textShow.node, textShow.edge), type = "chemical")
        metainfo<-rbind(metainfo,tmp.meta)
        
      }else{
        print("Input expression list provided, but no intersection with the given sub-graph.")
      }
    }else{
      print("Input expression list provided, but no RNA node exists in the given sub-graph.")
    }
  }
  
  # Add the ending of the graphml file
  out.graphml<-generate_ending(out.graphml)
  
  result<-list(graphml=out.graphml, metainfo=metainfo)
  return(result)
}

#' @title Remove unrelated nodes from the node vector of the sub-graph induced from Global Integrative Network (GIN)
#' @param input.gs The input list of nodes. Could be the names of genes and chemicals
#' @param tmp.node A vector of nodes which were extracted from GIN based on input.gs. Could be much larger than input.gs, since lots of intermediate nodes and participating nodes will be included.
#' @param graph The igraph object of GIN. Compatible with GINv2's or GINv3's igraph object.
#' @description Generate a list of node texts and the meta info. Meta info is useful for accelerating downstream conversion.
#' @return A vector of cleaned nodes.
#' @export
rm_unrelatedNodes<-function(input.gs,tmp.node,graph){
  tmp.node<-tmp.node[tmp.node %in% V(graph)$name]
  input.gs<-input.gs[input.gs %in% V(graph)$name]
  g.pw<-induced_subgraph(graph,tmp.node)
  ma.distance<-distances(g.pw,v = V(g.pw), to = input.gs, mode ="out")
  nf.new<-c()
  for(i in 1:dim(ma.distance)[1]){
    if(min(ma.distance[i,]) < Inf){
      #print(rownames(ma.distance)[i])
      nf.new<-c(nf.new,rownames(ma.distance)[i])
    }
  }
  return(nf.new)
}

#' @title Infer a node collection from Global Integrative Network based on an input list.
#' @param input.gs The input list of nodes. Could be the names of genes and chemicals
#' @param graph The igraph object of GIN. Compatible with GINv2's or GINv3's igraph object.
#' @param cdglist The list of coding genes' gene symbols.
#' @param num_cores Numeric. The number of cores to use for parallel computation when generating the node collection.
#' @description This is a wrapper of two major functions which generate node collections of signaling pathways and metabolic pathways.
#' @return A vector of nodes inferred from GIN based on a give gene/chemical list.
#' @export
generate_node_collection<-function(input.gs,graph,cdglist,num_cores = 6){
  nodeCollection<-generate_PPrel_node_collection(input.gs,graph, num_cores)
  nodeCollection<-unique(c(nodeCollection,
                           generate_metabolic_complex_node_collection(input.gs,graph,cdglist)))
  stopImplicitCluster()
  if(length(nodeCollection) == 0){
    print("No new nodes were introduced.")
    nodeCollection<-input.gs
  }
  return(nodeCollection)
}

#' @title Infer a node collection of signaling pathways from Global Integrative Network based on an input list.
#' @param input.gs The input list of nodes. Could be the names of genes and chemicals
#' @param graph The igraph object of GIN. Compatible with GINv2's or GINv3's igraph object.
#' @param num_cores Numeric. The number of cores to use for parallel computation when generating the node collection.
#' @description This is a wrapper of a core function which generate a node collection of signaling pathways. This function includes two steps, the first one is generating paths according to signaling pathways' structures. The second is to check these paths and collect the nodes.
#' @return A vector of nodes of signaling pathways inferred from GIN based on a give gene/chemical list.
#' @export
generate_PPrel_node_collection<-function(input.gs,graph, num_cores = 6){
  path.4check<-generate_signaling_path(input.gs,graph, num_cores)
  print(paste0("There are ",dim(path.4check)[1]," valid paths to check."))
  nodeCollection<-c()
  if(dim(path.4check)[1] > 0){
    nodeCollection<-get_node_by_path(path.4check,graph, num_cores = 6)  ###original code
    
    # Add the original nodes into the collection
    nodeCollection<-unique(c(nodeCollection,input.gs))
    print(paste0("Generated a node collection of ",length(nodeCollection),
                 " nodes for Protein-Protein relations."))
  }else{
    print(paste0("No paths of Protein-Protein relations found, skipping node generation for PPrel."))
    print("A null vector was generated.")
  }
  return(nodeCollection)
}

#' @title An epoch of collecting the nodes of a path.
#' @param i The index of the path, i.e. the row index of the dataframe path.4check.
#' @param path.4check A dataframe containing the paths to collect nodes. Two columns, starting nodes and ending nodes of the paths.
#' @param graph The igraph object of Global Integrative Network (GIN).
#' @description This is an epoch of collecting the nodes from a dataframe of path. This function will use the "all_shortest_paths" function from igraph package to get all the shortest paths from the starting node (column 1, row i) to the ending node (column 2, row i).
#' @return A vector of nodes of one signaling pathway inferred from GIN.
#' @export
get_node_by_path_epoch<-function(i,path.4check,graph){
  (sp<-all_shortest_paths(graph,path.4check[i,1],path.4check[i,2],mode = "out")$vpaths)
  nodeCollection<-c()
  if(length(sp) > 0){
    for(k in 1:length(sp)){
      (sp.tmp<-names(sp[[k]]))
      nodeCollection<-c(nodeCollection,sp.tmp)
    }
  }
  if(i %% 100 == 0){
    print(paste0("Done processing ",i,"th paths"))
  }
  return(nodeCollection)
}

#' @title Collect the nodes of paths.
#' @param path.4check A dataframe containing the paths to collect nodes. Two columns, starting nodes and ending nodes of the paths.
#' @param graph The igraph object of Global Integrative Network (GIN).
#' @param num_cores The number of cores to use for parallel computation.
#' @description Collect the nodes of paths in path.4check. Will call the function "get_node_by_path_epoch". Will add ".RNA" nodes if there are ".state" nodes (".state" nodes are gene promoter regions).
#' @return A vector of nodes of signaling pathways inferred from GIN.
#' @export
get_node_by_path<-function(path.4check,graph,num_cores){
  time.start=Sys.time()
  registerDoParallel(num_cores)
  nodeCollection<-foreach(i=1:dim(path.4check)[1], .combine = c) %dopar% {
    get_node_by_path_epoch(i=i,path.4check = path.4check, graph = graph)
  }
  # Add the .RNA nodes to the collection
  node.state<-nodeCollection[grep(".state",nodeCollection)]
  node.rna<-gsub(".state","",node.state)
  node.rna<-paste0(node.rna,".RNA")
  nodeCollection<-c(nodeCollection,node.rna)
  nodeCollection<-unique(nodeCollection)
  print(paste0("Time used: start from ",time.start,", end at ",Sys.time()))
  return(nodeCollection)
}

#' @title Collect the nodes of signaling pathways.
#' @param input.gs The input list of genes and/or chemicals.
#' @param graph The igraph object of Global Integrative Network (GIN).
#' @param num_cores The number of cores to use for parallel computation.
#' @description The input gene/chemical list will be used as the seed to generate the all the possible paths. The paths will then be checked to obey the structure of signaling pathways.
#' @return A vector of nodes of signaling pathways inferred from GIN.
#' @export
generate_signaling_path<-function(input.gs,graph, num_cores = 6){
  print("Start generating the signaling paths for input gene set in the graph")
  tmp.gs<-input.gs
  # Initial step of creating the path list
  print("Processing the initial neighbors of the input gene set.")
  
  tmp.neighbor<-create_neighbor_df(tmp.gs,graph,num_cores) # Paralleled
  
  tmp.examine<-examine_neighbor_df(tmp.neighbor,input.gs) # Note here we put "input.gs" into the function, because we are comparing with the original gene set
  tmp.gs<-unique(tmp.examine$itd$end)
  df.path<-tmp.examine$stop
  previous.path<-tmp.examine$itd
  print("Start looping to grow the path.")
  while(length(tmp.gs) > 0){ # This is dangerous because of infinite loops. Check the element of tmp.gs closely
    print(paste0("--tmp.gs of size ",length(tmp.gs)))
    
    tmp.neighbor<-create_neighbor_df(tmp.gs,graph,num_cores) # Paralleled
    
    tmp.examine<-examine_neighbor_df(tmp.neighbor,input.gs)
    tmp.gs<-unique(tmp.examine$itd$end)
    path.now<-get_path_info(previous.path, tmp.examine) # Generate the path info of starting and ending nodes
    if(dim(path.now$stop)[1]> 0){
      df.path<-rbind(df.path,path.now$stop)
    }
    previous.path<-path.now$itd # Updating the path info. Note that unique(path.now$itd$end) should be the same with tmp.gs
  }
  print(paste0("--tmp.gs of size ",length(tmp.gs), ", ending the loop"))
  # Cleaning
  df.path<-df.path[!df.path$start == df.path$end,] #remove the rows with the same nodes for starting and ending
  df.path<-unique(df.path)
  return(df.path)
}

#' @title Create a dataframe containing the neighbor nodes of a gene or chemical.
#' @param i The index of the gene/chemical in tmp.gs
#' @param tmp.gs A vector of genes/chemicals
#' @param graph The igraph object of Global Integrative Network (GIN).
#' @description An epoch to create a dataframe of a gene/chemical and its downstream neighbors by calling the function "neighbors" from package igraph. The mode is set to "out" to get the downstream neighbors only.
#' @return A dataframe with two columns. The first column is the given gene. The second column is the downstream neighbors.
#' @export
create_neighbor_df_epoch<-function(i,tmp.gs,graph){
  library(igraph)
  df.neighbor<-data.frame(start=c(),end=c())
  if(i == 1){
    if(length(V(graph)[names(V(graph)) == tmp.gs[i]]) > 0){
      if(length(names(neighbors(graph, tmp.gs[i],"out")) > 0)){
        df.neighbor<-data.frame(start=tmp.gs[i],end=names(neighbors(graph, tmp.gs[i],"out")))
      }else{
        print(paste0("No outgoing edge found for ",tmp.gs[i]))
      }
    }else{
      print(paste0("Gene not found: ",tmp.gs[i]))
    }
  }else{
    if(length(V(graph)[names(V(graph)) == tmp.gs[i]]) > 0){
      if(length(names(neighbors(graph, tmp.gs[i],"out")) > 0)){
        df.neighbor<-rbind(df.neighbor,data.frame(start=tmp.gs[i],end=names(neighbors(graph, tmp.gs[i],"out"))))
      }
    }else{
      print(paste0("Gene not found: ",tmp.gs[i]))
    }
  }
  return(df.neighbor)
}

#' @title Create a dataframe containing the input gene/chemical list and their downstream neighbors
#' @param tmp.gs A vector of input genes/chemicals.
#' @param graph The igraph object of Global Integrative Network (GIN).
#' @param num_cores The number of cores to use for parallel computation.
#' @description Create a dataframe of genes/chemicals in tmp.gs and their downstream neighbors by calling the function "neighbors" from package igraph. Has been paralleled.
#' @return A dataframe with two columns. The first column is the given genes. The second column is the downstream neighbors.
#' @export
create_neighbor_df<-function(tmp.gs,graph,num_cores = 6){
  #(time.start<-Sys.time())
  # Parallel the computation
  registerDoParallel(num_cores)
  tmp.neighbor<-foreach(i=1:length(tmp.gs), .combine = rbind) %dopar% {
    create_neighbor_df_epoch(i=i,tmp.gs = tmp.gs,graph = graph)
  }
  #print(paste0("Time used: start from ",time.start,", end at ",Sys.time()))
  return(tmp.neighbor)
}

#' @title Check the types of the ending nodes, and split the df into two
#' @param df1 A dataframe with two columns, starting nodes and ending nodes.
#' @param tmp.gs A vector of input gene/chemical list.
#' @description Check the types of the ending nodes, and split the df into two. One contains the intermeidate nodes, which should be further extended. The other one contains the products of reactions, which should stop the extension.
#' @return A list of two dataframes. The first one contains the intermediate nodes in the second column. The second one contains genes/chemicals/complexes in the second column.
#' @export
examine_neighbor_df<-function(df1,tmp.gs){ #check the types of the ending nodes, and split the df into two
  df.itd<-df1[grep(";",df1$end),] # Extract the ending nodes that are intermediates
  df.gene<-df1[grep(";",df1$end,invert = TRUE),]
  #df.RNA<-df1[grep(".RNA",df1$end),]
  # Those intermediate nodes need to be extended to find their neighbors
  # The gene nodes (GENE or GENE.state, should not exist GENE.RNA) need to be checked to see whether they exists in the given gene set
  tmp.gene<-gsub(".state","",df.gene$end)
  df.stop<-df.gene[tmp.gene %in% tmp.gs,]
  # The gene nodes which do not exist in the given gene set are dropped
  list.result<-list()
  list.result[[1]]<-df.itd
  list.result[[2]]<-df.stop
  names(list.result)<-c("itd","stop")
  return(list.result)
}

#' @title Extend the path.
#' @param previous.path A dataframe containing the paths' info before extension.
#' @param tmp.examine A dataframe containing the starting and ending nodes for extension.
#' @description The dataframe of paths are checked for the nodes' types and split into two dataframes which contains the next nodes for extension or the ending nodes of the paths. This function merge the original paths and the extensions to grow the path.
#' @return A list of two dataframes. The first one contains the intermediate nodes in the second column. The second one contains genes/chemicals/complexes in the second column.
#' @export
get_path_info<-function(previous.path, tmp.examine){
  path.now<-list()
  if(dim(tmp.examine$stop)[1] > 0){
    path.stop<-merge(previous.path,tmp.examine$stop,by.x = "end", by.y = "start")
    path.stop<-path.stop[,c(2,3)]
    colnames(path.stop)<-c("start","end")
    path.stop<-unique(path.stop)
    path.stop<-path.stop[!path.stop$start == path.stop$end,] #remove the rows with the same nodes for starting and ending
  }else{
    path.stop<-data.frame(start = "", end = "")
  }
  
  if(dim(tmp.examine$itd)[1] > 0){
    path.itd<-merge(previous.path,tmp.examine$itd, by.x = "end", by.y = "start")
    path.itd<-path.itd[,c(2,3)]
    colnames(path.itd)<-c("start","end")
    path.itd<-unique(path.itd)
  }else{
    path.itd<-data.frame(start = "", end = "")
  }
  
  path.now[[1]]<-path.itd
  path.now[[2]]<-path.stop
  names(path.now)<-c("itd","stop")
  return(path.now)
}

#' @title Generate the collection of nodes in the structures of metabolic pathways or complex formations
#' @param input.gs The input list of nodes. Could be the names of genes and chemicals
#' @param graph The igraph object of GIN. Compatible with GINv2's or GINv3's igraph object.
#' @param cdglist The list of coding genes' gene symbols.
#' @description Collect the nodes of mtabolic pathways or complex formations. Proteins usually function as enzymes in a metabolic reaction, therefore two proteins are separated by two nodes, an intermediate node and a chemical node. This is different from the signaling pathways, where proteins are separated by only one node, the intermediate node. This structure also fits the formation of complexes.
#' @return A vector of metabolic pathways' nodes inferred from GIN. Also contains nodes of complex formations.
#' @export
generate_metabolic_complex_node_collection<-function(input.gs,graph,cdglist){
  tmp.A<-input.gs
  print("Start generating the metabolic paths for input gene set in the graph.")
  print("A is the set of starting proteins. B is the intermediate nodes downstream of A.")
  print("C is the product of B and also the substrate of the intermediate node D.")
  tmp.B<-create_neighbor_df(tmp.A,graph)
  tmp.B<-tmp.B[grep(";",tmp.B$end),]
  nodes.itd<-tmp.B$end
  print(paste0("--Walking from A to B generates ",length(nodes.itd)," intermediate nodes B."))
  if(length(nodes.itd) > 0){
    tmp.C<-create_neighbor_df(nodes.itd,graph) # The df containing downstream nodes of the itds
    tmp.C<-tmp.C[!tmp.C$end %in% cdglist,] # Remove the ending nodes which are coding genes in C, leaving only chemical ids
    print(paste0("--Walking from B to C generates ",dim(tmp.C)[1]," paths."))
    if(dim(tmp.C)[1] > 0){
      tmp.D<-create_neighbor_df(tmp.C$end,graph) # This will walk to the next itd nodes if there is a metabolic pathway
      tmp.D<-tmp.D[grep(";",tmp.D$end),] # Remove nodes that are not itd nodes
      
      # Now, if a node in tmp.D$end exists in nodes.itd, then it means there is a pathway from A to D,
      # where A is a catabolic enzyme, B is the itd node of A, C is the product of B, and D is the next itd node of
      # C and another catabolic enzyme in A's vector.
      tmp.D<-tmp.D[tmp.D$end %in% nodes.itd,]
      tmp.D<-unique(tmp.D)
      print(paste0("--Walking from C to D generates ",dim(tmp.D)[1]," valid paths."))
      
      # Now we trace back from tmp.D to tmp.A to generate the node collection for metabolic pathways
      if(dim(tmp.D)[1] > 0){
        print("Now trace back the paths to generate the node collection.")
        tmp.C<-tmp.C[tmp.C$end %in% tmp.D$start,] # Filter tmp.C by tmp.D$start
        tmp.B<-tmp.B[tmp.B$end %in% tmp.C$start,] # Filter tmp.B by tmp.C$start
        nodeCollection.metabolic<-unique(c(tmp.D$end,tmp.D$start,tmp.C$start,tmp.B$start))
        # The last thing to do is to get the starting substrates and the end of the products of the pathways
        for(i in 1:length(tmp.D$end)){
          nodeCollection.metabolic<-unique(c(nodeCollection.metabolic,
                                             names(neighbors(graph, tmp.D$end[i],"all"))))
        }
        print(paste0("Generated a node collection of ",length(nodeCollection.metabolic),
                     " nodes for metabolic pathways and relations of complex."))
      }else{
        nodeCollection.metabolic<-c()
        print("No metabolic paths found. An empty vector was generated.")
      }
    }else{
      nodeCollection.metabolic<-c()
      print("Skip further walking. An empty vector was generated.")
    }
  }else{
    nodeCollection.metabolic<-c()
    print("Skip further walking. An empty vector was generated.")
  }
  return(nodeCollection.metabolic)
}

#' @title A simple function to generate a random integar
#' @param x The max integar.
#' @description This function calls "sample", and set size to 1.
#' @return A random number of integar, possible max is "x".
#' @export
randomSelect<-function(x){
  tmp<-sample(x,size=1)
  return(tmp)
}

#' @title Convert a vector of complex into a matrix
#' @param complexVec A vector of complex. The members of a complex are separated by "_".
#' @description Complexes are groups of members, which may be shared by different complexes. This function convert a given vector of complexes into a matrix to describe the members. It can be used for calculation of the intersections between complexes.
#' @return A two-dimensional matrix. The rows are complexes, the columns are members. If a complex contains certain members, then the corresponding elements in the matrix are set to 1, otherwise set to 0.
#' @export
convert_complexVec_to_matrix<-function(complexVec){
  complex.list<-strsplit(complexVec,"_")
  #names(complex.list)<-complexVec
  members<-unique(unlist(complex.list))
  members<-members[order(members,decreasing = FALSE)]
  
  result.ma<-matrix(0,nrow = length(complexVec), ncol = length(members))
  #dim(result.ma)
  colnames(result.ma)<-members
  #rownames(result.ma)<-c(complexVec)
  for(i in 1:length(complex.list)){
    result.ma[i,members %in% complex.list[[i]]]<-1
  }
  result.ma<-rbind(result.ma,diag(length(members)))
  rownames(result.ma)<-c(complexVec,members)
  return(result.ma)
}

#' @title Adjust the layout of nodes in a subgraph
#' @param g An igraph object. Should be a subgraph induced from GIN based on input.gs.
#' @param input.gs A list of genes/chemicals.l
#' @param node.color A vector of colors for: chemicals, complexes, intermediates, promoter regions, RNA transcripts, and proteins. Default is "yellow","brown","grey","blue","orange","red".
#' @param node.size A numeric vector of three elements to set the size of different types of nodes: the nodes not in the input list; the intermediate nodes; the nodes in the input list. Default is 5,3,7
#' @param cdglist.this A list of coding genes' symbols.
#' @description Adjust the color and size of the nodes.
#' @return An igraph object adjusted for nodes' colors and sizes.
#' @export
adjustNode_color_size<-function(g,input.gs,node.color=c("yellow","brown","grey","blue","orange","red"), node.size=c(5,3,7),cdglist.this=cdglist){
  node.tmp<-names(V(g)) #reset the order according to the graph object
  tmp.color<-rep(node.color[1],length(node.tmp))
  tmp.color[grepl("_",node.tmp)] = node.color[2]
  tmp.color[grepl(";",node.tmp)] = node.color[3]
  tmp.color[grepl(".state",node.tmp)] = node.color[4]
  tmp.color[grepl(".RNA",node.tmp)] = node.color[5]
  tmp.color[node.tmp %in% cdglist.this] = node.color[6]
  tmp.size<-rep(node.size[1],length(node.tmp))
  tmp.size[grepl(";",node.tmp)] = node.size[2]
  tmp.size[node.tmp %in% input.gs] = node.size[3]
  
  V(g)$color<-tmp.color
  V(g)$size<-tmp.size
  return(g)
}

#' @title Delete the transitions and edges associated with a mutated gene
#' @param mutGene A gene name, which is supposed to be functionally lost in the system.
#' @param result A list of two elements. First is a GraphML list. Second is the metainfo (a dataframe).
#' @description Simulate the effects of functional lost of a mutated gene by deleting the associated transitions and arcs. Should be clear of the gene's function and its direct impact. Use this function under professional guidances of biological meanings.
#' @return A list of two elements. First is a GraphML list without transitions and arcs related to a mutated gene. Second is the metainfo (a dataframe).
#' @export
generate_mut_graphml<-function(mutGene,result){
  # Delete mutGene related transitions
  mymeta<-result$metainfo
  (id.mut<-mymeta$id[mymeta$textShow == mutGene])
  vec.id.edge<-mymeta$id[grep(paste0(id.mut,"_n"),mymeta$textShow)]
  vec.del<-vec.id.edge # The edges: mutGene -> transitions
  
  vec.id.node<-mymeta$textShow[mymeta$id %in% vec.id.edge]
  (vec.id.node<-t(matrix(unlist(strsplit(vec.id.node,"_")),nrow = 2))[,2])
  vec.del<-c(vec.del,vec.id.node) # The nodes: transitions
  
  vec.id.edge<-c()
  for(j in 1:length(vec.id.node)){
    tmp.id.edge<-mymeta$id[grep(paste0(vec.id.node[j],"_n"),mymeta$textShow)]
    vec.id.edge<-c(vec.id.edge,tmp.id.edge) # The edges: transitions -> regulated-nodes
    tmp.id.edge<-mymeta$id[grep(paste0("_",vec.id.node[j],"_"),mymeta$textShow)]
    vec.id.edge<-c(vec.id.edge,tmp.id.edge) # The edges: others -> transitions
  }
  vec.del<-c(vec.del,vec.id.edge)
  
  result$graphml<-result$graphml[!names(result$graphml) %in% vec.del]
  return(result)
}

#' @title Analyze the composition of nodes' types
#' @param g.sub An igraph object. The names of the nodes will be fetched by "V(g.sub)$name".
#' @param cdglist A list of coding genes' gene symbols.
#' @description Count the number of nodes in different types.
#' @return A named numeric vector which contains the counts of different types of nodes.
#' @export
analyze_node_composition<-function(g.sub,cdglist=cdglist){
  node.name<-V(g.sub)$name
  n.itd<-length(node.name[grep(";",node.name)])
  node.name<-node.name[!grepl(";",node.name)]
  n.state<-length(node.name[grep(".state",node.name)])
  n.RNA<-length(node.name[grep(".RNA",node.name)])
  node.name<-node.name[!grepl(".state",node.name)]
  node.name<-node.name[!grepl(".RNA",node.name)]
  n.complex<-length(node.name[grep("_",node.name)])
  node.name<-node.name[!grepl("_",node.name)]
  n.cdg<-length(node.name[node.name %in% cdglist])
  node.name<-node.name[!node.name %in% cdglist]
  n.chemical<-length(node.name)
  result<-c(n.itd,n.state,n.RNA,n.complex,n.cdg,n.chemical)
  names(result)<-c("n_itd","n_promoter","n_RNA","n_complex","n_cdg","n_chemical")
  return(result)
}

#' @title Find the longest path in an igraph object
#' @param graph An igraph object.
#' @param source The name of the source node.
#' @param target The name of the target node.
#' @description Find the longest paths in an igraph object for two nodes.
#' @return An edge list containing the longest path from a source node to a target node.
#' @export
longest_path<-function(graph,source,target){
  # Step 1: Perform topological sorting
  topo_order <- topo_sort(graph, mode = "out")
  
  # Step 2: Initialize distances and predecessors
  # First locate the position of the source node
  (index.source<-which(names(topo_order) == source)) # the index of the source node in the distance vector
  (index.target<-which(names(topo_order) == target)) # the index of the target node in the distance vector
  dist <- rep(-Inf, vcount(graph)) #initialize the distance vector
  dist[index.source] <- 0 # the distance between source node and source node itself is 0
  predecessor <- rep(NA, vcount(graph)) # the vector to record the predecessor of the node with current index position. Only record the longest path's predecessor
  
  # Step 3: Dynamic programming to find the longest path
  (index.this = index.source) # initialize index.this. The algorithm only considers current node (index.this) and the next node (index.next)
  (nextnode<-names(neighbors(graph, topo_order[index.this], mode = "out"))) # a dynamic vector to store the next nodes of the current node.
  while(length(nextnode) > 0){
    tmp.next<-c()
    index.update<-NA
    for(v.next in nextnode){
      (index.next<-which(names(topo_order) == v.next))
      if (dist[index.this] + 1 > dist[index.next]) {
        dist[index.next] <- dist[index.this] + 1
        predecessor[index.next] <- index.this
        index.update<-index.next
      }else if(dist[index.this] + 1 == dist[index.next]){
        print(paste0("Warning: Equal length of paths exist"))
      }
      tmp.next<-c(tmp.next,names(neighbors(graph, topo_order[index.next], mode = "out")))
    }
    if(!is.na(index.update)){
      index.this<-index.update
    }
    nextnode<-unique(na.omit(tmp.next))
  }
  
  # If the target node is not reachable
  if (is.infinite(dist[index.target])) {
    #print("No path from source to target, NA generated.")
    return(NA)
  } else {
    # Step 4: Trace back to find the longest path
    path<-all_simple_paths(graph,from = source, to = target, mode = "out")
    
    path.result<-list()
    dist[dist == -Inf] = -1
    dist.target<-dist[index.target]
    for(i in 1:length(path)){
      if(length(path[[i]]) == dist.target + 1){ # Vertex number = distance + 1
        n = length(path.result)
        path.result[[n+1]]<-path[[i]]
      }else if(length(path[[i]]) > dist.target + 1){
        print("Unexpected path which is larger than the max distance calculated.")
      }
    }
    return(path.result)
  }
}

#' @title Add the parent nodes to a vector of node.
#' @param vec.node An vector of node names.
#' @param graph The igraph object of GIN.
#' @description Find the intermediate nodes, and add the substrate/enzyme nodes to the input vector.
#' @return A vector of node names.
#' @export
add_parentNodes<-function(vec.node,graph=graph){
  node.itd<-vec.node[grepl(";",vec.node)]
  node.parent<-c()
  for(i in 1:length(node.itd)){
    node.parent<-c(node.parent,names(neighbors(graph,node.itd[i], mode = "in")))
  }
  vec.node<-unique(c(vec.node,node.parent))
  return(vec.node)
}

#' @title Convert a vector of protein complex into a matrix
#' @param complexVec An vector of complex names. The protein members are separated by "_".
#' @description Convert a vector of protein complex into a matrix.
#' @return A numeric matrix of 0 and 1. The rows are protein complexes. The columns are protein members. 1 means the protein member is one of the components of the complex. 0 means not.
#' @export
convert_complexVec_to_matrix<-function(complexVec){
  complex.list<-strsplit(complexVec,"_")
  members<-unique(unlist(complex.list))
  members<-members[order(members,decreasing = FALSE)]
  
  result.ma<-matrix(0,nrow = length(complexVec), ncol = length(members))
  colnames(result.ma)<-members
  for(i in 1:length(complex.list)){
    result.ma[i,members %in% complex.list[[i]]]<-1
  }
  result.ma<-rbind(result.ma,diag(length(members)))
  rownames(result.ma)<-c(complexVec,members)
  return(result.ma)
}

#' @title Add complex formation paths and gene regulatory network to an igraph object
#' @param g.subgraph The igraph object which needs to add complex formation paths and GRN.
#' @param input.gs A vector of input genes.
#' @param graph.grn An igraph object created from edgelist of Gene Regulatory Network.
#' @param cdglist A vector of all coding genes' gene symbols.
#' @description When inducing a sub-graph from GIN based on an input gene/chemical list, lots of protein complexes are included. However, the paths that form these complexes are not generated, since their protein members may not be in the input gene/chemical list. This function finds all the protein complexes and generate paths for the formation of the complexes. The paths may be sufficient for simulation of signal flows, but may not be accurate, therefore needs manual curations. This function will also add gene regulatory networks to the input igraph object.
#' @return An igraph object which contains complex formation paths and gene regulatory networks.
#' @export
add_prcFormation_and_GRN<-function(g.subgraph,input.gs,graph.grn,cdglist){
  print("Generating paths for protein complex formation.")
  myComplex<-V(g.pw)$name[grep("_",V(g.subgraph)$name)]
  myComplex<-myComplex[!grepl(";",myComplex)]
  complex.ma<-convert_complexVec_to_matrix(myComplex)
  num.shared.ma<-complex.ma %*% t(complex.ma)
  num.member.vec<-rowSums(complex.ma)
  sim.ma<-num.shared.ma
  for(i in 1:dim(sim.ma)[2]){
    sim.ma[,i]<-sim.ma[,i]/num.member.vec
  }
  sim.ma[sim.ma < 1] = 0
  
  g.tmp<-graph_from_adjacency_matrix(sim.ma,mode = "directed",diag = FALSE)
  
  members<-unique(unlist(strsplit(myComplex,"_")))
  members<-members[order(members,decreasing = FALSE)]
  
  vec.from<-c()
  vec.to<-c()
  allnodes<-c(members,myComplex)
  for(i in 1:length(allnodes)){
    for(j in 1:length(myComplex)){
      if(allnodes[i] != myComplex[j]){
        (path.tmp<-longest_path(g.tmp,allnodes[i],myComplex[j]))
        if(length(path.tmp) > 0){
          for(k in 1:length(path.tmp)){
            (vec.path<-names(path.tmp[[k]]))
            (n.vec<-length(vec.path))
            (vec.from<-c(vec.from,vec.path[1:(n.vec-1)]))
            (vec.to<-c(vec.to,vec.path[2:n.vec]))
          }
        }
      }
    }
  }
  edge.complex<-unique(as.matrix(data.frame(source=vec.from,target=vec.to, type="positive")))
  node.target<-unique(edge.complex[,2])
  
  vec.from<-c()
  vec.to<-c()
  for(i in 1:length(node.target)){
    (el.tmp<-edge.complex[edge.complex[,2] == node.target[i],])
    (node.itd<-paste(sort(el.tmp[,1]),collapse = ";"))
    (vec.from<-c(vec.from,el.tmp[,1],node.itd))
    (vec.to<-c(vec.to,rep(node.itd,length(el.tmp[,1])),node.target[i]))
  }
  edge.complex.sifi<-as.matrix(data.frame(source=vec.from, target=vec.to, type="positive"))
  
  edge.core<-data.frame(as_edgelist(g.subgraph))
  edge.core$type<-E(g.subgraph)$type
  colnames(edge.core)<-c("source","target","type")
  edge.core.withComplex<-rbind(edge.core,edge.complex.sifi)
  
  g.core.withComplex<-graph_from_edgelist(as.matrix(edge.core.withComplex[,c(1,2)]),)
  E(g.core.withComplex)$type = edge.core.withComplex[,3]
  print("Done adding paths for protein complex formation.")
  
  print("Generating gene regulatory network for given graph.")
  gene.grn<-unique(c(input.gs,members))
  node.grn<-generate_node_collection(gene.grn,graph.grn,cdglist,num_cores = 6)
  node.grn<-node.grn[node.grn %in% V(graph.grn)$name]
  g.grn<-induced_subgraph(graph.grn,node.grn)
  
  el.grn<-data.frame(as_edgelist(g.grn))
  el.grn$type<-"positive"
  gene2add<-gene.grn[!gene.grn %in% unique(el.grn[,2])]
  gene2add<-gene2add[gene2add %in% cdglist]
  
  colnames(el.grn)<-c("source","target","type")
  el.grn<-rbind(el.grn,data.frame(source=paste0(gene2add,".RNA"),target = gene2add,type="positive"))
  
  edge.final<-rbind(edge.core.withComplex,el.grn)
  edge.final<-unique(edge.final)
  
  g.final<-graph_from_edgelist(as.matrix(edge.final[,c(1,2)]),)
  E(g.final)$type = edge.final[,3]
  return(g.final)
}
